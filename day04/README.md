# 认识所有权

[code](ownership/)

## 什么是所有权

### 所有权规则

* rust中每个值都有一个对应的变量作为它的所有者
* 在同一时间内，值有且仅有一个所有者
* 当所有者离开自己的作用域时，它持有的值就会被释放

### 变量作用域

* 变量定义完成，在进入作用域后变得有效
* 变量会保持自己的有效性直到离开作用域

### String类型

* String的值是存储在堆内存上的

### 内存与分配

* 对于实现Copy trait的类型，变量赋值意味着数据的复制，比如 `let y = x;`
* 对于实现Drop trait的类型，变量赋值意味着数据的移动, 比如 `let s2: String = s1;`
* rust不允许实现Drop trait的类型再去实现Copy trait
* 对于实现Drop trait的类型，要实现深拷贝就使用 `clone()` 函数， 比如 `let s2: String = s1.clone();`
* 使用堆上数据的类型，实现Drop trait，调用 `drop()` 函数就会调用`Drop()`回收内存，这一般由编译器自动完成

### 所有权与函数

* 将变量传递给函数将会发生移动或者复制
* 函数在返回值的过程中也会发生所有权的转移

## 引用与借用

由于所有权规则导致变量传值麻烦而低效，因此需要 **引用** 来满足一些传值的需求，这种通过引用传递参数的方法就叫借用

* 使用 `&` 符号用于表示引用，比如 `&String`，也可以用于取引用， 比如 `&s1` 。
* 使用 `*` 符号用于解引用，不过由于rust有一套自动解引用的规则，因此大多数时候不需要手动解引用
* 默认的引用是不可变引用，也就是所指向的内容不允许修改

### 可变引用

* 使用 `&mut` 定义可变引用， 比如 `&mut String`

可变引用允许修改所指向的值，但是 **对于特定作用域中的特定数据来说，一次只能声明一个可变引用**

* 不允许在已有不可变引用的情况下，再创建可变引用

### 悬垂引用

* rust不允许悬垂引用，编译直接报错

## 切片

除了引用， 切片也是一种不持有所有权的数据类型

### 字符串切片

字符串切片是值String对象中某个连续部分的引用， 比如

```rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11]
```

* 字符串的切片边界必须位于有效UTF-8字符边界
* 字符串字面量就是切片， 比如 `"hello world"`

### 其他类型的切片

数组切片

```rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
```